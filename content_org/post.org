#+AUTHOR: Terrence Ho
#+HUGO_BASE_DIR: ../

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

** DONE Writing My Blog Posts with Org                       :emacs:hugo:org:
   CLOSED: [2019-06-30 Sun 18:15]
:PROPERTIES:
:EXPORT_FILE_NAME: org-blog-posts
:END:

Hugo is an awesome blog generator. However, it's primary content mode is
Markdown, and writing in =org-mode= feels much better than writing in Markdown.
=org-mode= can automatically convert to Markdown, but then I have to edit the
generated Markdown file to add YAML front-matter that Hugo consumes, which is
annoying.

Enter [[https://www.gnu.org/software/emacs/][=ox-hugo=]]. It allows you to maintain and generate Hugo-compatible Markdown
in =org-mode=, and automatically generates the necessary metadata Hugo requires.
However, like all good things in life, you have to work a little to configure it
to your liking. (What's an extension without spending a couple hours of life
figuring out exactly how to make it conform to your workflow in the pursuit of
"optimization"). This is how I configure =ox-hugo= to write all my blog posts
(including this blog post!).


*** Setup

**** Installation

Install the package [[https://ox-hugo.scripter.co/][=ox-hugo=]]. If you use =use-package= to manage your packages,
the following snippet should do the trick.

#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :ensure t            ;Auto-install the package from Melpa (optional)
  :after ox)
#+END_SRC

I would recommend going through =ox-hugo='s documentation for maximum
effectiveness.

**** Base Directory

In a Hugo website, you might have a directory structure that looks the following
layout. From now on, we will refer to this root directory as =HUGO_ROOT_DIR=.

#+BEGIN_EXAMPLE
.
├── config.toml
├── content
│   └── post
│       ├── post1.md
│       ├── new-post.md
├── content_org
│   └── post.org
├── layouts
│   └── partials
├── public
│   ├── content
│   │   └── post
#+END_EXAMPLE

Note that I have only shown the necessary parts, your actual directory structure
will have many other files. =org= doesn't care about Hugo's directory structure,
so I added a new directory called =content-org=. This is where I store all my
=org= files for the blogs. We only need one =org= file, named post.org.

**** Global Properties

Open up =$(HUGO_ROOT_DIR)/content_org/post.org= in Emacs. At the very top,
insert the following (replace =<your-name=here>= with your name).

#+BEGIN_EXAMPLE
#+AUTHOR: <your-name-here>
#+HUGO_BASE_DIR: ../
#+END_EXAMPLE

This sets the author to be your name, and more importantly sets where
=$(HUGO_ROOT_DIR)= is located at. In this case, the root directory is simply the
parent directory. If your root directory is elsewhere, adjust =HUGO_BASE_DIR=
appropriately. Setting =HUGO_BASE_DIR= is necessary for =ox-hugo= to set where
it will be exporting files.

Next, create a headline called Posts. Underneath, add the following properties.

#+BEGIN_EXAMPLE
 * Posts
 :PROPERTIES:
 :EXPORT_HUGO_SECTION: post
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER:
 :END:
#+END_EXAMPLE

=EXPORT_HUGO_SECTION= sets the directory under content to generate blog posts.
Here we've set the export directory to be post, which corresponds to
=$(HUGO_ROOT_DIR)/content/post=. Under =EXPORT_HUGO_CUSTOM_FRONT_MATTER=, you
can set other YAML matter that you want to apply to all posts, such as
configuring BlackFriday options (Hugo's markdown processor).

**** Posts per Subtree


We've now setup the basics of =ox-hugo=. Next, we will look at how to write a
blog post.

Most blog posts intuitively are written as one file per post. However, =ox-hugo=
allows us to write all of our blog posts in one single file, and export to many
different files. Thus, all of my blog posts live in
=$(HUGO_ROOT_DIR)/content_org/post.org=, and eack blog post is exported as many
different files under =$(HUGO_ROOT_DIR)/content/post/=.

The motivation behind this lies with how =org-mode= lists work. In a =org-mode=
list we can set TODO items, and manipulate the entries using =org-mode=
shortcuts. Then in a sense, we can think of a blog post as a TODO item, and
everything underneath the TODO item is the content of the blog post itself. We
can even mark a blog post as DONE to "release" it. Below is an example of the
collapsed view of the Posts tree. There are three blog posts, with one marked
as DONE, and the rest TODO or IN-PROGRESS. (To collapse a subtree in =org-mode=,
press =S-TAB=. You can then press =TAB= on the POSTS headline to see
sub-headlines underneath it.)

#+BEGIN_EXAMPLE
 * Posts
 ** TODO Go Essentials Part 1                               :go:go_essentials:⤵
 ** IN-PROGRESS Microsoft Internship                    :microsoft:internship:⤵
 ** DONE How I started Using Emacs                                 :emcas:org:⤵
#+END_EXAMPLE

Thus in a nutshell, we have the Posts top level headline, then TODO items as
secondary headlines. Each TODO item is a blog post, either finished or
unfinished. Any content underneath the secondary headlines is part of the actual
blog post. In the snippet above, I have collapsed the content, leaving only a ⤵
to indicate there is data underneath the headline. All your blog posts live
under the Posts subtree. So anytime you want to edit a blog post, you open
=$(HUGO_ROOT_DIR)/content_org/post.org= and edit the appropriate subtree.

**** Blog Properties

We also want to be able to add some properties to an individual blog post. We
can do so like this:

#+BEGIN_EXAMPLE
 * Posts
 ** TODO Next Blog Post
 :PROPERTIES:
 :EXPORT_FILE_NAME: how-i-started-using-emacs
 :END:
#+END_EXAMPLE

This sets the file name to be exported to. There are other properties you can
set, all detailed in the =ox-hugo= docs. All the properties are translated to
Hugo YAML front-matter. In this fashion, =ox-hugo= allows you to set file
specific YAML front-matter in an =org-mode=-like way.

**** Tags

=ox-hugo= can also generate the tags in the YAML front-matter. You can set the
tags in each blog headline such as the following. This saves you the trouble of
having to write the tabs into the =PROPERTIES= themselves, since that is
slightly more troublesome. Additionally, this makes use of =org-mode= tags,
allowing =org-mode= to format your tags nicely.

#+BEGIN_EXAMPLE
 * Posts
 ** TODO Next Blog Post                                           :tag1:tag2:
#+END_EXAMPLE

These tags allow you to group related posts. Hugo can read these tags and link
all blog posts with the same tags, so this is a very neat feature.

**** Publishing a Blog Post

To publish a blog post, set the blog post from TODO to DONE. (For those new to
=org-mode=, you can do this by pressing =C-c C-t=. This should bring up a side
window that allows you to set the status of the TODO item.) If you have
configured your =org-mode= to output a date at which when an item was finished,
=ox-hugo= will automatically set that date at the publishing date, which is much
more convenient than setting the date manually. An example is shown in the
section below.

**** Putting it all together

Here is an example of the Posts subtree along with two blog posts, one finished
and one unfinished. The finished blog post has a CLOSED timestamp indicating the
date at which it was finsihed. The unfinished blog post is considered a draft to
Hugo, and so Hugo won't compile that blog post unless Hugo is set to compile the
drafts as well.

#+BEGIN_EXAMPLE
 #+AUTHOR: Terrence Ho
 #+HUGO_BASE_DIR: ../
 * Posts
 ** TODO Next Blog Post
 :PROPERTIES:
 :EXPORT_FILE_NAME: next-blog-post-name
 :END:

 Introductory text... Ipsum Lorem

 *** First Headline

 More text... Ipsum Lorem

 **** First Sub-Headline

 Even more text... Ipsum Lorem

 ** DONE Other Finished Blog Post
    CLOSED: [2019-06-17 Mon 16:53]
 :PROPERTIES:
 :EXPORT_FILE_NAME: other-finished-blog-post
 :END:

 This blog post was finished one Monday, June 17th, 2019.
#+END_EXAMPLE

*** Converting to Markdown

Lastly, once all this is set up, we will want to convert out posts to Markdown
files. Luckily, =ox-hugo= also builds in an exporter to complement =org-mode='s
exporting capabilities.

To export a subtree as a post, press =C-c C-e=. This should bring up a side menu
detailing all the export methods available to you. Press =H H= to export the
subtree as a file (altogether, press =C-c C-e H H=). =ox-hugo= determines where
to export based on the previous settings. You can also export all subtrees at
once with =C-c C-e H A=. If you don't use the option to write your blog posts as
subtrees, but rather one blog post per =org= file, then use =C-c C-e H h=, which
exports everything in the file to Markdown. Personally, I structure my blog
posts in the subtree style, because of how well it fits the =org-mode= workflow,
but YMMV.

The exporting side view looks like the following:

#+CAPTION: =org-mode= exporting view
#+NAME:   fig:org-mode exporting view
[[file:org-mode-exporting-view.png]]


*** Conclusion.

I hope you've enjoyed learning how to write blog posts with =org-mode=. I've
honestly never enjoyed writing Markdown, and so this gives me a convenient and
fun way to write my future blog posts. Stay tuned for more similiar content!

** DONE How I Started Using Emacs                                 :emacs:org:
   CLOSED: [2019-06-17 Mon 16:53]
   :PROPERTIES:
   :EXPORT_FILE_NAME: how-i-started-using-emacs
   :END:

This is how I started using GNU Emacs with no prior experience. This is intended
to help those who want to start using Emacs as well. I'll start from a base
setup, show you where I looked around for help, show you how I found myself
using my current configuration. While this post goes through the steps to get
started with Emacs, I definitely omitted the steps that didn't help or the parts
where I floundered around not knowing what I was doing.

My primary motivation for using Emacs was its =org-mode=, Emac's organizational
software. I heard amazing things about the spread sheets, the TODO lists,
agendas, calendars, note-taking, paper writing, life dominating capabilities, so
I had to try it out. Even if it meant entering the Church of Emacs for a short
while.

*** Installing Emacs

Even though Emacs can be used through a terminal emulator, it's best to use GUI
Emacs (unlike GUI Vim, which offers no other benefits compared to Terminal VIm)
because in GUI Emacs, you can display images, view PDF documents, interact with
the system clipboard natively out the of the box, rich text formatting options,
and more. Therefore, always use GUI Emacs, it offers so much more capabilities.

On Mac OS, you can just run =brew cask install emacs= and it should
automatically download the latest stable version. For reference, at the time of
this post I was using Emacs 26.2.

For those that want to build from source or install in a different manner,
consult [[https://www.emacswiki.org/emacs/EmacsForMacOS][this page]].

*** To be or not to be =evil=

For the unaware, =evil= mode is a popular Emacs Vi mode emulation layer (I'm
sure the name has no other connotation at all). I've used vim extensively in the
past, but I wasn't sure if I wanted to try and use =evil= in Emacs straight
away, since I would have no idea about shortcut conflicts, or what parts Emacs
does better than vim. Therefore, I decided to try using plain Emacs and start
from there.

*** Plain Emacs

I gave a genuine try to use pure Emacs, by going through the tutorial (=C-h t=),
however, I could not get used to it. I was too used to using HJKL to navigate
between lines. The amount of times I pressed =i= to enter Insert mode and then
forget I wasn't in vim was uncountable; same with pressing =ESC= to leave Insert
mode and then realizing I wasn't in Insert mode. I honestly cannot fathom for my
life how using =C-n= and =C-p= to move up and down lines can be part of any sane
workflow. In fact, I found that a lot of 1 key press actions in Vim's insert
mode require multiple key presses in Emacs. Vim's editing keybindings were just
too crucial to me to immediately switch.

Because of this, I bit the bullet and started researching the best way to
install =evil= into Emacs. Enter the world of Emacs configurations.

*** Emacs Configuration

To the best of my knowledge, using the =use-package= plugin is the best way to
configure Emacs and various package options. According to the [[https://github.com/jwiegley/use-package][README]],
=use-package= allows you to "isolate package configuration in your .emacs file
in a way that is both performance-oriented and tidy". It seems to be widely used
and easy to install, so that's the package manager I settled on. To install
=use-package=, open the .emacs file in your home directory and paste this in.

#+BEGIN_SRC emacs-lisp
;; Configure package.el to include MELPA.

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+END_SRC

This code (written in ELisp), simply requires =package.el=, Emacs' built in
package manager. It adds the package archive Melpa to the list of repositories,
an online repository store of Emacs packages. Melpa seems to be the most
complete and almost every project is one Melpa, so I only use Melpa. It's
possible to add more if needed, of course.

Now that we have initialized the default package manager, we'll use that to
install =use-package=.

#+BEGIN_SRC emacs-lisp
;; Ensure that use-package is installed.
;;
;; If use-package isn't already installed, it's extremely likely that this is a
;; fresh installation! So we'll want to update the package repository and
;; install use-package before loading the literate configuration.
(when (not (package-installed-p 'use-package))
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Now whenever we want to install some other package, we can use =use-package= to
install that package.

*** Install =evil=

Let's use =use-package= to install =evil= get join the dark side of Emacs. Paste
this into your .emacs file.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-mode 1))
#+END_SRC

=use-package= searches the package archives for something called =evil=, sets
any configurations, and then activates evil mode. Now you can restart Emacs, and
you should automatically be in =evil= mode. Try typing some text and editing it
using the key bindings.

If you open up your .emacs file again, you can see that emacs generated some
extra code that looks something like this:

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(package-selected-packages
   (quote use-package ...)
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
#+END_SRC

This is automatically generated and you shouldn't worry about it. If you
accidentally ignore the warnings not to mess with it as I did, you can simply
delete all of it, restart Emacs, and it should be automatically regenerated.

Now that we have =evil= mode set up, let's turn to =org= mode.

*** =org= mode

Now as stated in the beginning, my primary goal was to be able to get started
with =org= mode, for all its organizational goodies. =org= comes preinstalled on
later versions, Emacs but if necessary, you can also just install =org= using
=use-package=. I spent a lot of time going through tutorials and various other
resouces, and a lot of them are quite good, so I'm going to list a couple
resources.

- [[https://orgmode.org/guide/][Org-mode Guide]]
- [[https://orgmode.org/worg/][Worg]]
- [[https://orgmode.org/manual/index.html][Org-mode Manual]]

I suggest going through the Org-mode guide the most, it has the best concise
documentation of the most commonly used features.

*** Configurations with =org-babel=

One of the cooler things that =org= can do is write code blocks inline and
execute them. Take the Hello World function defined in Python below.

#+NAME: hello-world
#+BEGIN_SRC python :results output
import random
print("Hello, this is a random number:", random.random())
#+END_SRC

#+RESULTS: hello-world
: ('Hello, this is a random number:', 0.35818895069511747)

In an =org=-file, it would look like this (notice that we name the code block):

#+BEGIN_EXAMPLE
#+NAME: hello-world
#+BEGIN_SRC python :results output
import random
print("Hello, this is a random number:", random.random())
#+END_SRC
#+END_EXAMPLE

We can then call that code block by executing it. With your cursor in the
code-block, press =C-c C-c=. The output should be as follows.

#+BEGIN_EXAMPLE
#+RESULTS: hello-world
: ('Hello, this is a random number:', 0.35818895069511747)
#+END_EXAMPLE

So you can execute arbitrary code in an =org= mode file. This is obviously very
cool and also a little dangerous. Always make sure you know what code you're
executing, because this allows arbitary code execution on your system (this is
the Emacs equivalent of falling for a phishing attack).

Even more important is that this implies that you can write Emacs Lisp in your
=org= file and then execute it. So why not write your configuration file in an
=org= file, and then execute it? This allows you to document your configuration
in the same file as your configuration file. You could theoretically do the same
for any code file using comments, but =org= mode is just so much more featured
that it just feels better to write in =org=.

In fact, my current configuration file is actually just an =org= file. My .emacs
is very minimal. Aside from the code to install =use-package=, I only have one
more manually written line:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/configuration.org")
#+END_SRC

=org-babel-load-file= parses an org-file, extracts all the code segments, and
places it into it's own dedicated file that is then executed. so my
"~/.emacs.d/configuration.el" is generated by =org-babel= from my
"~/.emacs.d/configuration.org" file. You can do this as well. IMO, writing in
=org= just feels much better than writing pure Emacs Lisp.

For the remainder of this article, I'm going to install a couple things by
writing the installation/configuration code in =org=. You can copy this Emacs
Lisp code into your own configuration org file. In my configuration =org= file,
I always try to comment the code above it, so I know what I did reading it years
later.

For reference, my entire .emacs file:

#+BEGIN_SRC emacs-lisp
;; ===== Custom load definition.
;; ===== Load from configuration org file

;; Configure package.el to include MELPA.
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)

;; Ensure that use-package is installed.
;;
;; If use-package isn't already installed, it's extremely likely that this is a
;; fresh installation! So we'll want to update the package repository and
;; install use-package before loading the literate configuration.
(when (not (package-installed-p 'use-package))
  (package-refresh-contents)
  (package-install 'use-package))

(org-babel-load-file "~/.emacs.d/configuration.org")
#+END_SRC

*** Theme

The theme of your editor could be even more important than the actual editor
itself. After all, you gotta make your coworkers jealous when they see how cool
your system looks.

Personally, I'm a fan of the [[https://github.com/hlissner/emacs-doom-themes][Doom City Lights Theme]].

#+CAPTION: Doom City Lights, courtesy of [[https://github.com/hlissner/emacs-doom-themes][hlissner]]
#+NAME:   fig:doom-city-lights
[[https://github.com/hlissner/emacs-doom-themes/raw/screenshots/doom-citylights.png]]

To install this, paste the following code into your configuration.org file.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :init
  (load-theme 'doom-city-lights t)
  :config
  (setq doom-themes-enable-bold nil    ; if nil, bold is universally disabled
        doom-themes-enable-italic nil) ; if nil, italics is universally disabled
  (doom-themes-org-config)
  )
#+END_SRC
#+END_EXAMPLE

*** Sane Emacs Configurations

A lot of the default configurations for Emacs are a little outdated to say
the least. [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] is a collection of Emacs configurations that are
relatively non-intrusive and useful, including:

- Ensuring that files end with newlines,
- Always enabling syntax highlighting,
- Increasing the garbage collection threshold,
- Defaulting line-length to 80 characters,
- Creating parent directories after saving a deeply nested file,
- Making dired file sizes human-readable

and more. Because they are all exported as several ELisp functions, you can pick
the ones that you want to use, or simply include all of them by running

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(load "~/code/src/github.com/hrs/sensible-defaults.el/sensible-defaults.el")
(sensible-defaults/use-all-settings)
(sensible-defaults/use-all-keybindings)
#+END_SRC
#+END_EXAMPLE

That's it. I find some of the configurations non-obvious, so I pick and choose
the ones I want, and add a few of my own custom configurations, but
sensible-defaults.el is still a good option to look at.

*** Personal Information

This is totally unnecessary, but if you want Emacs to know who you are, then
set:

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
 (setq user-full-name "Terrence Ho"
       user-mail-address "terrenceho.books@gmail.com")
 #+END_SRC
#+END_SRC
#+END_EXAMPLE

*** =org= TODOs

One of the most powerful features of =org= is it's TODO management. Any line
starting with several bullet points (Ex: ***) is a headline. Headlines can
become TODO items if the first word on the headline is TODO or DONE.

Let's assume that we want to set more than just TODO/DONE states. I have
multiple states set up, such as TODO, IN-PROGRESS, WAITING, DONE, and CANCELLED.
Note that we also want the CANCELLED state to be equivalent to a DONE state,
since if something is cancelled, we don't want it to be done in the future.
Adapt the following code according to how you want to set up your TODOs.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
(setq org-todo-keywords
  '((sequence "TODO(t)" "IN-PROGRESS(i)" "WAITING(w@)" "|" "DONE(d)" "CANCELLED(c@)")))
(setq org-todo-keyword-faces
      '(("TODO" :foreground "red" :weight bold)
	  ("IN-PROGRESS" :foreground "blue" :weight bold)
	  ("WAITING" :foreground "orange" :weight bold)
	  ("DONE" :foreground "forest green" :weight bold)
	  ("CANCELLED" :foreground "magenta" :weight bold)))
#+END_SRC
#+END_EXAMPLE

This changes the sequence of TODO states, adding the necessary states. Notice
the "@" in the CANCELLED and WAITING states: they indicate that we can add a
note explaining what an item is waiting for or why something was cancelled.

=org= by default allows you to switch states by pressing =S-LEFT= pr =S-RIGHT=.
However, when we have multiple states, we often want to switch directly to the
desired state. Add the following code to enable this option.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq org-use-fast-todo-selection t)
#+END_SRC
#+END_EXAMPLE

To switch TODO states, place your cursor onto the headline, then press =C-c
C-t=. This should bring up another buffer listing the possible states. Press the
key corresponding to your desired state, and your headline should automatically
change to reflect that.

*** =org= ellipsis

When you are hovering over a headline, you can press =TAB=. This collapses all
the text underneath the headline, and replaces the text with an ellipsis (...).
I didn't like the ellipsis, so I replaced it with a "⤵".

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⤵")
(set-face-attribute 'org-ellipsis nil :foreground "##61a49e")
#+END_SRC
#+END_EXAMPLE

*** =org= pretty bullets

The number of the bullets in your headline indicates different levels of
headlines, and they correspond to different importance levels (* matches to
=<h1>=, ** matches to =<h2>=, etc). I'd prefer to look at some prettier,
indented bullets, so I replaced them with a package called =org-bullets=.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC
#+END_EXAMPLE

*** =org= file converters

=org= can export to a bunch of different file systems. I'll go over the formats
I have set up, but in the future if you need to write a paper and transform it
into PDF or HTML format, consider writing in =org= rather than LaTex (powerful
but annoying to write) or Markdown (non-standardized and Markdown tables suck).

To convert a file, press =C-c C-e=. This should being up a side panel listing a
bunch of options to convert your files. Choose which file format to convert to,
and Emacs should output that file.

**** HTML/Markdown

=htmlize= is a package that helps you convert =org= files to an HTML page.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
   (use-package htmlize)
#+END_SRC
#+END_EXAMPLE

**** PDF/LaTex

=org= can export to PDF thorugh LaTex if you have a Tex toolchain available on
your system automatically.

**** GitHub Flavored Markdown

GitHub has it's own flavour of markdown. Well no matter, we can export to that
too. Never directly write a README.md directly again!

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm)
(eval-after-load "org"
  '(require 'ox-gfm nil t))
#+END_SRC
#+END_EXAMPLE

**** Hugo

This blog is generated with Hugo. I can write my blog posts in =org=, export
them to hugo compatible Markdown with front-matter intact, and publish them.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :ensure t            ;Auto-install the package from Melpa (optional)
  :after ox)
#+END_SRC
#+END_EXAMPLE

*** Conclusion

My journey into Emacs and Org-Mode has been quite successful. To demonstrate,
I've written this blog post using =org=, and I hopefully plan on never writing
Markdown again. My current, ever updating configuration file can be seen at
[[https://github.com/TerrenceHo/dotfiles][My GitHub]]. Check out the ".emacs.d/configuration.org" file, GitHub can render
=org= files now!

I went from writing code manually in the .emacs file and ended up writing all my
configurations in an =org= file, that holds both the source code and
documentation for my configurations. I then also went into a brief overview
about how I configure Emacs and =org= mode specifically.

Emacs is endlessly configureable. There are insanely powerful plugins such as
MaGit (git plugin), Projectile (session/project management), Helm (completion
framework), TRAMP (SSH remote file support), autocomplete and language servers,
and more. I am still figuring out all these other tools, which goes to show how
awesome Emacs really is.

I should have a blog post up soon detailing how I organize my blog posts using
=ox-hugo=. Stay tuned for that!


** TODO Go Essentials Part 1                               :go:go_essentials:
   :PROPERTIES:
   :EXPORT_FILE_NAME: go-essentials-part-1
   :END:

*** Constructors

*** Interfaces

*** Lambda functions

*** Type Alias

*** =iota= and =enums=

*** Networking

*** Reader and Writer interfaces
** TODO Go Essentials Part 2                               :go:go_essentials:
   :PROPERTIES:
   :EXPORT_FILE_NAME: go-essentials-part-2
   :END:

*** Goroutines

*** Channels

*** Data sharing and locks
** TODO A Deep Dive into gzip's Codebase Part 1                      :C:gzip:
   :PROPERTIES:
   :EXPORT_FILE_NAME: gzip-deep-dive-part-1
   :END:
** TODO Integrating =zlib= into =gzip=                               :C:gzip:
   :PROPERTIES:
   :EXPORT_FILE_NAME: gzip-integrate-zlib
   :END:
** TODO Parallelizing gzip                          :C:gzip:parallel:threads:
   :PROPERTIES:
   :EXPORT_FILE_NAME: parallelizing-gzip
   :END:
** TODO My Journey as a Developer                                   :journey:
   :PROPERTIES:
   :EXPORT_FILE_NAME: my-journey
   :END:

This is a never-ending post of my journey as a developer.
** TODO Garbled Circuits Research                  :research:garbled_ciruits:

*** Explain Garbled Circuits

*** Explain the leaky bit problem

*** Explain our attempts to solve it
** TODO UCLA DevX internal tools             :DevX:go:backend:postgres:redis:
** TODO Computability: Recursion Theorem and the Halting Problem   :research:
** TODO My new grad job search and my view on interviews     :interviews:job:
   :PROPERTIES:
   :EXPORT_FILE_NAME: new_grad_interview_thoughts
   :END:

As of November 6th, 2019, I have officially secured a job at Robinhood. Now that
I have a little more free time, I'm going to detail some of my thoughts
regarding job searches in general.

Note that I will go over my relevant thoughts before diving into my personal job
search story (bragging). Feel free to read the parts only relevant to you.

*** A note on unfairness

There is undoubtedly variance in job searching. There is luck involved, and
nothing is guaranteed. This is true overall in life. Ideally, the more effort
you put in, the greater/better the output.

What's even worse however, is that job searches favor the privileged and the
already successful suck up many opportunities surrounding them. This makes
sense: if someone is already successful, it doesn't make sense for a company to
take a chance on someone who is less experienced, ignoring other factors. Wealth
and privilege undeniably makes this problem worse, since wealth equates to
more resources available to the wealthy that may not be available to the less
fortunate (prep schools, SAT/ACTs, Ivy League donations). So not everyone starts
out on the same foot.

On the bright side, everyone had to come from somewhere. The idea is to maximize
your discoverability, so that you are best positioned to take advantage of an
opportunity when it arises, and to position yourself in the best way to expose
yourself to as many opportunities as possible.

*** Maximizing Signalling and Discoverability

What are companies looking for in job screenings? That is the eternal question.



Interviews and resume screenings are attempts to pick up some measure (job
productivity, work output, dedication, etc) through some other metrics (where
you have worked in the past,

**** Referrals

Referrals are the dirty underpinnings of discoverability in tech job searches,
and probably job searches in any industry. It is undeniably a mechanism that
allows the well connected to nudge out those who may be equally qualified for a
job position.

Companies highly value referrals because working with someone you know is vastly
preferred to working with random strangers. You are probably going to able to
talk more about certain ideas, you are more comfortable asking each other for
help, etc. Remember that companies are not looking for pure technical talent.
They are also looking for personable individuals who can espouse their own
ideas, take criticism, and generally get along with other co-workers.
Egotistical 10x wonders have their place, but a company who hires arrogant
assholes is probably one that you want to avoid anyway. (This is not to say that
arrogant asshole are always smarter; there exist idiotic arrogant assholes, and
smart, genuine, friendly individuals.)

However, referrals also allow a way in for newer players. Otherwise, the set of
qualified individuals would never grow. The key is getting to know more people
that have connections to the industries you are targetting. Make friends with
some of these people, and have them refer you. Most are happy to do it.

For the unconvinced, here are some statistics from my latest job hunt that
highlight how much of a difference referrals make. I received 14 referrals from
various connections; 7 of these referrals resulted in a positive response,
usually a coding challenge. I also applied to jobs through company online
portals, 35 online applications in total. Only 6 out of these 35 online
applications resulted in a coding challenge. For those that like percentages,
50% of referrals resulted in a positive response, whereas only 16% of my online
applications resulted in a positive response. While not statistically
significant, I am sure that this trend is repeated all over.

Online applications are available to anyone: that means that anyone who is
shotgunning applications is also applying the same way. Thus, by the law of
averages, the pool of applications from online portals is filled with much more
unqualified applicants. If the company believes it's employees to be above
average (which most companies do, paradoxically)


**** Go to a well respected college

The following only applies to students in high school or college. The best way
to maximize your career impact is to go to a well respected college. It
undeniably gives you a huge advantage.

***** Smart people want to work with smart people

There is the perception that top colleges have on average smarter people. (I
think this is true by the way.) Regardless of whether it is true or not, the
perception that it is true is all that matters. Thus, all the bright young
students will gravitate towards these colleges.

Feeds into referrals.
***** Companies want to hire smart people

Because of the perception that top colleges have smarter people, companies then
heavily recruit at these top schools.

There is an interesting trend at UCLA. Top public companies (think Google,
Facebook, Amazon, Microsoft) are increasingly skipping our engineering fair. I
know they still attend for UC Berkeley and MIT career fairs, but because of the
volume of applications, they seem to have decided that it is not worth going to
some lesser ranked schools. I wouldn't even consider UCLA low or even medium
ranked, it is certainly one of the top schools, but if even UCLA is being
skipped, that says something about the volume of applicants they are getting and
the quality of applicants they are getting.

If UCLA is being passed over by these top tech companies, then what about
no-name colleges or state colleges? While some companies may attend those career
fairs, there are then inherently fewer opportunities to network for.

Companies heavily rely on past signalling to decide what they should do. If most
of their recruits are from top engineering schools, why would they decide to do
differently? It is undeniably a perpetuating cycle, that favors those who are in
top colleges, and will continue to do so. This is unfortunate, because there are
undoubtedly many bright students who are not fortunate enough to attend a
expensive top college. However, from a company's point of view, there are ten
times the number of gifted students at top universities.

There is some question of how much debt you should take on for college, but that
is up to you to decide with your own financial means. All I am pointing out is
that going to a top college gives you a definite career advantage.

***** It's not the end of the world

If you don't go to a top college, it's not the end of the world. Don't panic.
College only really matters for your first job. However, better networking in
college gives you access to valuable/prestigious interships.

It's a head start. It's possible to catch up. It will require working from
behind, but at the same time, a job is just a job.

**** Resume signalling

The following is some resume advice.

**** Avoiding Application Paralysis

You just have to apply. You have to get yourself out there.

I got my Microsoft internship by applying, being rejected, then emailed to apply
and sent straight to the final rounds for an internship.

After I got Microsoft, my discoverability for applications went way higher for
the new grad job cycle the following year.

**** When to apply?

For college cycles, apply as early as in august.

Market analogy, trading early.


*** Job search trends

**** Debugging interviews are on the rise.

**** Algorithm interviews are still highly present.

**** Apply to jobs other than software engineering.

Jobs such as Site Reliability Engineer (SRE), security, infrastructure
engineering, etc pay just as much as regular jobs, and perhaps even more.
According to the [[https://insights.stackoverflow.com/survey/2019][StackOverflow 2019 Survey]], DevOps and Site Reliability
Engineers were among the highest paid types of developers. At the new grad
level, from what I have seen SRE and security positions seem to have the same
promotional track as regular software engineering.

This also explains the rise of debugging interviews as mentioned earlier.

**** Know language specifics

Some companies looking for candidates that know their language. It's a dumb
practice, since most langauges are quite easy to learn and I believe that
problem solving fundamentals are most important. However, if you know that a
company will ask you Java specific questions for example, study up on the
specifics on Java. (Then again, if they are working in Java, maybe you don't
want to work there anyway. I know, that was a low blow.)

**** Job openings flows and ebbs

My return offer for Microsoft expired on Nov 1st, 2019. I had 7 weeks to mull
over the offer, negotiate, and apply to other companies (thank you UCLA career
policies). However, that means they held my spot for 7 weeks. I imagine that
after I declined my Microsoft offer they were able to open more spots in their
new grad pipeline, since they had to fill my vacant spot. Thus, while companies
may be full at one point, some more openings may become available later on, as
candidates decline offers and/or renege on accepted offers.

Unfortunately, timing these opening windows is like trying to time the market:
it's impossible. Therefore, the key thing to remember is to keep applying to
jobs no matter what, there may be some openings later on.

*** My Job Search

Got a referral for Stripe, got to the onsite. Woke up at 6:30 AM to a fire
alarm, promptly got a massive headache. Tylenol only killed part of the headache
by the time my interview started. The interview was somewhat difficult, I got
flustered, my headache got worse, I got rejected two days later. I was
incredibly disappointed. I honestly thought that I had screwed up my chance to
work at a company I would loved to work at.

Thus began my long search for other companies.

I was promptly rejected by Facebook even with a referral. That sucked.

I secured an onsite for VMWare, with a simple HackerRank. No phone interview
required.

I got to the second phone screens for Blend and Affirm. I was not
surprised to hear that I did not pass since I had flubbed both phone
screens, but for Affirm I was very surprised to hear I was not moving onto the
onsite since my interviewer had assured me he would recommend me for the onsite.
I speculate that they did not need more backend engineers in the pipeline, or
that the new grad pipeline in general was too full, and they could not accomdate
my schedule.

Additionally, Dropbox cancelled a phone interview with me, citing the fact that
their new grad pipeline was too full. Redfin cancelled their onsite with me,
citing that they had filled up all the new grad positions they were hiring for.
These two emails came within one hour of each other, amusingly.

Finally, one week before my Microsoft return offer would expire, I scheduled
three back to back onsites: LinkedIn (SRE), Robinhood (Security Software
Engineer), and the Voleon Group (Software Engineer). I learned everything I
could about network protocols, distributed systems, system design, and debugging
for LinkedIn. For my Robinhood, I got some premonition that I would need to
brush up on proving algorithms, and I am very glad I did. The Voleon onsite was
quite weird, they had me sitting there doing literal HackerRanks while another
engineer in the room did their own work; I could ask questions, but most of it
was just me working on the problems.

I came out of that with offers from VMWare, LinkedIn, and Robinhood. VMWare
could not match the comphensation for the other two companies, my Microsoft
return offer expired, and it was down to Robinhood and LinkedIn. I chose
Robinhood because I was interested in going into security, their culture was
pretty cool, and I wanted to do some high impact work. It was quite close in
the end however. I ended up cancelling onsites for Amazon and Akuna Capital,
since their onsites were after my Microsoft deadline, and frankly I was tired of
interviewing.

* Projects
:PROPERTIES:
:EXPORT_HUGO_SECTION: project
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

** govdev
** autofresh
** BruinBite
