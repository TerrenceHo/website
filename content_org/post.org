#+AUTHOR: Terrence Ho
#+HUGO_BASE_DIR: ../

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

** DONE Writing My Blog Posts with Org                       :emacs:hugo:org:
   CLOSED: [2019-06-30 Sun 18:15]
:PROPERTIES:
:EXPORT_FILE_NAME: org-blog-posts
:END:

Hugo is an awesome blog generator. However, it's primary content mode is
Markdown, and writing in =org-mode= feels much better than writing in Markdown.
=org-mode= can automatically convert to Markdown, but then I have to edit the
generated Markdown file to add YAML front-matter that Hugo consumes, which is
annoying.

Enter [[https://www.gnu.org/software/emacs/][=ox-hugo=]]. It allows you to maintain and generate Hugo-compatible Markdown
in =org-mode=, and automatically generates the necessary metadata Hugo requires.
However, like all good things in life, you have to work a little to configure it
to your liking. (What's an extension without spending a couple hours of life
figuring out exactly how to make it conform to your workflow in the pursuit of
"optimization"). This is how I configure =ox-hugo= to write all my blog posts
(including this blog post!).


*** Setup

**** Installation

Install the package [[https://ox-hugo.scripter.co/][=ox-hugo=]]. If you use =use-package= to manage your packages,
the following snippet should do the trick.

#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :ensure t            ;Auto-install the package from Melpa (optional)
  :after ox)
#+END_SRC

I would recommend going through =ox-hugo='s documentation for maximum
effectiveness.

**** Base Directory

In a Hugo website, you might have a directory structure that looks the following
layout. From now on, we will refer to this root directory as =HUGO_ROOT_DIR=.

#+BEGIN_EXAMPLE
.
├── config.toml
├── content
│   └── post
│       ├── post1.md
│       ├── new-post.md
├── content_org
│   └── post.org
├── layouts
│   └── partials
├── public
│   ├── content
│   │   └── post
#+END_EXAMPLE

Note that I have only shown the necessary parts, your actual directory structure
will have many other files. =org= doesn't care about Hugo's directory structure,
so I added a new directory called =content-org=. This is where I store all my
=org= files for the blogs. We only need one =org= file, named post.org.

**** Global Properties

Open up =$(HUGO_ROOT_DIR)/content_org/post.org= in Emacs. At the very top,
insert the following (replace =<your-name=here>= with your name).

#+BEGIN_EXAMPLE
#+AUTHOR: <your-name-here>
#+HUGO_BASE_DIR: ../
#+END_EXAMPLE

This sets the author to be your name, and more importantly sets where
=$(HUGO_ROOT_DIR)= is located at. In this case, the root directory is simply the
parent directory. If your root directory is elsewhere, adjust =HUGO_BASE_DIR=
appropriately. Setting =HUGO_BASE_DIR= is necessary for =ox-hugo= to set where
it will be exporting files.

Next, create a headline called Posts. Underneath, add the following properties.

#+BEGIN_EXAMPLE
 * Posts
 :PROPERTIES:
 :EXPORT_HUGO_SECTION: post
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER:
 :END:
#+END_EXAMPLE

=EXPORT_HUGO_SECTION= sets the directory under content to generate blog posts.
Here we've set the export directory to be post, which corresponds to
=$(HUGO_ROOT_DIR)/content/post=. Under =EXPORT_HUGO_CUSTOM_FRONT_MATTER=, you
can set other YAML matter that you want to apply to all posts, such as
configuring BlackFriday options (Hugo's markdown processor).

**** Posts per Subtree


We've now setup the basics of =ox-hugo=. Next, we will look at how to write a
blog post.

Most blog posts intuitively are written as one file per post. However, =ox-hugo=
allows us to write all of our blog posts in one single file, and export to many
different files. Thus, all of my blog posts live in
=$(HUGO_ROOT_DIR)/content_org/post.org=, and eack blog post is exported as many
different files under =$(HUGO_ROOT_DIR)/content/post/=.

The motivation behind this lies with how =org-mode= lists work. In a =org-mode=
list we can set TODO items, and manipulate the entries using =org-mode=
shortcuts. Then in a sense, we can think of a blog post as a TODO item, and
everything underneath the TODO item is the content of the blog post itself. We
can even mark a blog post as DONE to "release" it. Below is an example of the
collapsed view of the Posts tree. There are three blog posts, with one marked
as DONE, and the rest TODO or IN-PROGRESS. (To collapse a subtree in =org-mode=,
press =S-TAB=. You can then press =TAB= on the POSTS headline to see
sub-headlines underneath it.)

#+BEGIN_EXAMPLE
 * Posts
 ** TODO Go Essentials Part 1                               :go:go_essentials:⤵
 ** IN-PROGRESS Microsoft Internship                    :microsoft:internship:⤵
 ** DONE How I started Using Emacs                                 :emcas:org:⤵
#+END_EXAMPLE

Thus in a nutshell, we have the Posts top level headline, then TODO items as
secondary headlines. Each TODO item is a blog post, either finished or
unfinished. Any content underneath the secondary headlines is part of the actual
blog post. In the snippet above, I have collapsed the content, leaving only a ⤵
to indicate there is data underneath the headline. All your blog posts live
under the Posts subtree. So anytime you want to edit a blog post, you open
=$(HUGO_ROOT_DIR)/content_org/post.org= and edit the appropriate subtree.

**** Blog Properties

We also want to be able to add some properties to an individual blog post. We
can do so like this:

#+BEGIN_EXAMPLE
 * Posts
 ** TODO Next Blog Post
 :PROPERTIES:
 :EXPORT_FILE_NAME: how-i-started-using-emacs
 :END:
#+END_EXAMPLE

This sets the file name to be exported to. There are other properties you can
set, all detailed in the =ox-hugo= docs. All the properties are translated to
Hugo YAML front-matter. In this fashion, =ox-hugo= allows you to set file
specific YAML front-matter in an =org-mode=-like way.

**** Tags

=ox-hugo= can also generate the tags in the YAML front-matter. You can set the
tags in each blog headline such as the following. This saves you the trouble of
having to write the tabs into the =PROPERTIES= themselves, since that is
slightly more troublesome. Additionally, this makes use of =org-mode= tags,
allowing =org-mode= to format your tags nicely.

#+BEGIN_EXAMPLE
 * Posts
 ** TODO Next Blog Post                                           :tag1:tag2:
#+END_EXAMPLE

These tags allow you to group related posts. Hugo can read these tags and link
all blog posts with the same tags, so this is a very neat feature.

**** Publishing a Blog Post

To publish a blog post, set the blog post from TODO to DONE. (For those new to
=org-mode=, you can do this by pressing =C-c C-t=. This should bring up a side
window that allows you to set the status of the TODO item.) If you have
configured your =org-mode= to output a date at which when an item was finished,
=ox-hugo= will automatically set that date at the publishing date, which is much
more convenient than setting the date manually. An example is shown in the
section below.

**** Putting it all together

Here is an example of the Posts subtree along with two blog posts, one finished
and one unfinished. The finished blog post has a CLOSED timestamp indicating the
date at which it was finsihed. The unfinished blog post is considered a draft to
Hugo, and so Hugo won't compile that blog post unless Hugo is set to compile the
drafts as well.

#+BEGIN_EXAMPLE
 #+AUTHOR: Terrence Ho
 #+HUGO_BASE_DIR: ../
 * Posts
 ** TODO Next Blog Post
 :PROPERTIES:
 :EXPORT_FILE_NAME: next-blog-post-name
 :END:

 Introductory text... Ipsum Lorem

 *** First Headline

 More text... Ipsum Lorem

 **** First Sub-Headline

 Even more text... Ipsum Lorem

 ** DONE Other Finished Blog Post
    CLOSED: [2019-06-17 Mon 16:53]
 :PROPERTIES:
 :EXPORT_FILE_NAME: other-finished-blog-post
 :END:

 This blog post was finished one Monday, June 17th, 2019.
#+END_EXAMPLE

*** Converting to Markdown

Lastly, once all this is set up, we will want to convert out posts to Markdown
files. Luckily, =ox-hugo= also builds in an exporter to complement =org-mode='s
exporting capabilities.

To export a subtree as a post, press =C-c C-e=. This should bring up a side menu
detailing all the export methods available to you. Press =H H= to export the
subtree as a file (altogether, press =C-c C-e H H=). =ox-hugo= determines where
to export based on the previous settings. You can also export all subtrees at
once with =C-c C-e H A=. If you don't use the option to write your blog posts as
subtrees, but rather one blog post per =org= file, then use =C-c C-e H h=, which
exports everything in the file to Markdown. Personally, I structure my blog
posts in the subtree style, because of how well it fits the =org-mode= workflow,
but YMMV.

The exporting side view looks like the following:

#+CAPTION: =org-mode= exporting view
#+NAME:   fig:org-mode exporting view
[[file:org-mode-exporting-view.png]]


*** Conclusion.

I hope you've enjoyed learning how to write blog posts with =org-mode=. I've
honestly never enjoyed writing Markdown, and so this gives me a convenient and
fun way to write my future blog posts. Stay tuned for more similiar content!

** DONE How I Started Using Emacs                                 :emacs:org:
   CLOSED: [2019-06-17 Mon 16:53]
   :PROPERTIES:
   :EXPORT_FILE_NAME: how-i-started-using-emacs
   :END:

This is how I started using GNU Emacs with no prior experience. This is intended
to help those who want to start using Emacs as well. I'll start from a base
setup, show you where I looked around for help, show you how I found myself
using my current configuration. While this post goes through the steps to get
started with Emacs, I definitely omitted the steps that didn't help or the parts
where I floundered around not knowing what I was doing.

My primary motivation for using Emacs was its =org-mode=, Emac's organizational
software. I heard amazing things about the spread sheets, the TODO lists,
agendas, calendars, note-taking, paper writing, life dominating capabilities, so
I had to try it out. Even if it meant entering the Church of Emacs for a short
while.

*** Installing Emacs

Even though Emacs can be used through a terminal emulator, it's best to use GUI
Emacs (unlike GUI Vim, which offers no other benefits compared to Terminal VIm)
because in GUI Emacs, you can display images, view PDF documents, interact with
the system clipboard natively out the of the box, rich text formatting options,
and more. Therefore, always use GUI Emacs, it offers so much more capabilities.

On Mac OS, you can just run =brew cask install emacs= and it should
automatically download the latest stable version. For reference, at the time of
this post I was using Emacs 26.2.

For those that want to build from source or install in a different manner,
consult [[https://www.emacswiki.org/emacs/EmacsForMacOS][this page]].

*** To be or not to be =evil=

For the unaware, =evil= mode is a popular Emacs Vi mode emulation layer (I'm
sure the name has no other connotation at all). I've used vim extensively in the
past, but I wasn't sure if I wanted to try and use =evil= in Emacs straight
away, since I would have no idea about shortcut conflicts, or what parts Emacs
does better than vim. Therefore, I decided to try using plain Emacs and start
from there.

*** Plain Emacs

I gave a genuine try to use pure Emacs, by going through the tutorial (=C-h t=),
however, I could not get used to it. I was too used to using HJKL to navigate
between lines. The amount of times I pressed =i= to enter Insert mode and then
forget I wasn't in vim was uncountable; same with pressing =ESC= to leave Insert
mode and then realizing I wasn't in Insert mode. I honestly cannot fathom for my
life how using =C-n= and =C-p= to move up and down lines can be part of any sane
workflow. In fact, I found that a lot of 1 key press actions in Vim's insert
mode require multiple key presses in Emacs. Vim's editing keybindings were just
too crucial to me to immediately switch.

Because of this, I bit the bullet and started researching the best way to
install =evil= into Emacs. Enter the world of Emacs configurations.

*** Emacs Configuration

To the best of my knowledge, using the =use-package= plugin is the best way to
configure Emacs and various package options. According to the [[https://github.com/jwiegley/use-package][README]],
=use-package= allows you to "isolate package configuration in your .emacs file
in a way that is both performance-oriented and tidy". It seems to be widely used
and easy to install, so that's the package manager I settled on. To install
=use-package=, open the .emacs file in your home directory and paste this in.

#+BEGIN_SRC emacs-lisp
;; Configure package.el to include MELPA.

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+END_SRC

This code (written in ELisp), simply requires =package.el=, Emacs' built in
package manager. It adds the package archive Melpa to the list of repositories,
an online repository store of Emacs packages. Melpa seems to be the most
complete and almost every project is one Melpa, so I only use Melpa. It's
possible to add more if needed, of course.

Now that we have initialized the default package manager, we'll use that to
install =use-package=.

#+BEGIN_SRC emacs-lisp
;; Ensure that use-package is installed.
;;
;; If use-package isn't already installed, it's extremely likely that this is a
;; fresh installation! So we'll want to update the package repository and
;; install use-package before loading the literate configuration.
(when (not (package-installed-p 'use-package))
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Now whenever we want to install some other package, we can use =use-package= to
install that package.

*** Install =evil=

Let's use =use-package= to install =evil= get join the dark side of Emacs. Paste
this into your .emacs file.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-mode 1))
#+END_SRC

=use-package= searches the package archives for something called =evil=, sets
any configurations, and then activates evil mode. Now you can restart Emacs, and
you should automatically be in =evil= mode. Try typing some text and editing it
using the key bindings.

If you open up your .emacs file again, you can see that emacs generated some
extra code that looks something like this:

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(package-selected-packages
   (quote use-package ...)
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
#+END_SRC

This is automatically generated and you shouldn't worry about it. If you
accidentally ignore the warnings not to mess with it as I did, you can simply
delete all of it, restart Emacs, and it should be automatically regenerated.

Now that we have =evil= mode set up, let's turn to =org= mode.

*** =org= mode

Now as stated in the beginning, my primary goal was to be able to get started
with =org= mode, for all its organizational goodies. =org= comes preinstalled on
later versions, Emacs but if necessary, you can also just install =org= using
=use-package=. I spent a lot of time going through tutorials and various other
resouces, and a lot of them are quite good, so I'm going to list a couple
resources.

- [[https://orgmode.org/guide/][Org-mode Guide]]
- [[https://orgmode.org/worg/][Worg]]
- [[https://orgmode.org/manual/index.html][Org-mode Manual]]

I suggest going through the Org-mode guide the most, it has the best concise
documentation of the most commonly used features.

*** Configurations with =org-babel=

One of the cooler things that =org= can do is write code blocks inline and
execute them. Take the Hello World function defined in Python below.

#+NAME: hello-world
#+BEGIN_SRC python :results output
import random
print("Hello, this is a random number:", random.random())
#+END_SRC

#+RESULTS: hello-world
: ('Hello, this is a random number:', 0.35818895069511747)

In an =org=-file, it would look like this (notice that we name the code block):

#+BEGIN_EXAMPLE
#+NAME: hello-world
#+BEGIN_SRC python :results output
import random
print("Hello, this is a random number:", random.random())
#+END_SRC
#+END_EXAMPLE

We can then call that code block by executing it. With your cursor in the
code-block, press =C-c C-c=. The output should be as follows.

#+BEGIN_EXAMPLE
#+RESULTS: hello-world
: ('Hello, this is a random number:', 0.35818895069511747)
#+END_EXAMPLE

So you can execute arbitrary code in an =org= mode file. This is obviously very
cool and also a little dangerous. Always make sure you know what code you're
executing, because this allows arbitary code execution on your system (this is
the Emacs equivalent of falling for a phishing attack).

Even more important is that this implies that you can write Emacs Lisp in your
=org= file and then execute it. So why not write your configuration file in an
=org= file, and then execute it? This allows you to document your configuration
in the same file as your configuration file. You could theoretically do the same
for any code file using comments, but =org= mode is just so much more featured
that it just feels better to write in =org=.

In fact, my current configuration file is actually just an =org= file. My .emacs
is very minimal. Aside from the code to install =use-package=, I only have one
more manually written line:

#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.emacs.d/configuration.org")
#+END_SRC

=org-babel-load-file= parses an org-file, extracts all the code segments, and
places it into it's own dedicated file that is then executed. so my
"~/.emacs.d/configuration.el" is generated by =org-babel= from my
"~/.emacs.d/configuration.org" file. You can do this as well. IMO, writing in
=org= just feels much better than writing pure Emacs Lisp.

For the remainder of this article, I'm going to install a couple things by
writing the installation/configuration code in =org=. You can copy this Emacs
Lisp code into your own configuration org file. In my configuration =org= file,
I always try to comment the code above it, so I know what I did reading it years
later.

For reference, my entire .emacs file:

#+BEGIN_SRC emacs-lisp
;; ===== Custom load definition.
;; ===== Load from configuration org file

;; Configure package.el to include MELPA.
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)

;; Ensure that use-package is installed.
;;
;; If use-package isn't already installed, it's extremely likely that this is a
;; fresh installation! So we'll want to update the package repository and
;; install use-package before loading the literate configuration.
(when (not (package-installed-p 'use-package))
  (package-refresh-contents)
  (package-install 'use-package))

(org-babel-load-file "~/.emacs.d/configuration.org")
#+END_SRC

*** Theme

The theme of your editor could be even more important than the actual editor
itself. After all, you gotta make your coworkers jealous when they see how cool
your system looks.

Personally, I'm a fan of the [[https://github.com/hlissner/emacs-doom-themes][Doom City Lights Theme]].

#+CAPTION: Doom City Lights, courtesy of [[https://github.com/hlissner/emacs-doom-themes][hlissner]]
#+NAME:   fig:doom-city-lights
[[https://github.com/hlissner/emacs-doom-themes/raw/screenshots/doom-citylights.png]]

To install this, paste the following code into your configuration.org file.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :init
  (load-theme 'doom-city-lights t)
  :config
  (setq doom-themes-enable-bold nil    ; if nil, bold is universally disabled
        doom-themes-enable-italic nil) ; if nil, italics is universally disabled
  (doom-themes-org-config)
  )
#+END_SRC
#+END_EXAMPLE

*** Sane Emacs Configurations

A lot of the default configurations for Emacs are a little outdated to say
the least. [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] is a collection of Emacs configurations that are
relatively non-intrusive and useful, including:

- Ensuring that files end with newlines,
- Always enabling syntax highlighting,
- Increasing the garbage collection threshold,
- Defaulting line-length to 80 characters,
- Creating parent directories after saving a deeply nested file,
- Making dired file sizes human-readable

and more. Because they are all exported as several ELisp functions, you can pick
the ones that you want to use, or simply include all of them by running

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(load "~/code/src/github.com/hrs/sensible-defaults.el/sensible-defaults.el")
(sensible-defaults/use-all-settings)
(sensible-defaults/use-all-keybindings)
#+END_SRC
#+END_EXAMPLE

That's it. I find some of the configurations non-obvious, so I pick and choose
the ones I want, and add a few of my own custom configurations, but
sensible-defaults.el is still a good option to look at.

*** Personal Information

This is totally unnecessary, but if you want Emacs to know who you are, then
set:

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
 (setq user-full-name "Terrence Ho"
       user-mail-address "terrenceho.books@gmail.com")
 #+END_SRC
#+END_SRC
#+END_EXAMPLE

*** =org= TODOs

One of the most powerful features of =org= is it's TODO management. Any line
starting with several bullet points (Ex: ***) is a headline. Headlines can
become TODO items if the first word on the headline is TODO or DONE.

Let's assume that we want to set more than just TODO/DONE states. I have
multiple states set up, such as TODO, IN-PROGRESS, WAITING, DONE, and CANCELLED.
Note that we also want the CANCELLED state to be equivalent to a DONE state,
since if something is cancelled, we don't want it to be done in the future.
Adapt the following code according to how you want to set up your TODOs.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
(setq org-todo-keywords
  '((sequence "TODO(t)" "IN-PROGRESS(i)" "WAITING(w@)" "|" "DONE(d)" "CANCELLED(c@)")))
(setq org-todo-keyword-faces
      '(("TODO" :foreground "red" :weight bold)
	  ("IN-PROGRESS" :foreground "blue" :weight bold)
	  ("WAITING" :foreground "orange" :weight bold)
	  ("DONE" :foreground "forest green" :weight bold)
	  ("CANCELLED" :foreground "magenta" :weight bold)))
#+END_SRC
#+END_EXAMPLE

This changes the sequence of TODO states, adding the necessary states. Notice
the "@" in the CANCELLED and WAITING states: they indicate that we can add a
note explaining what an item is waiting for or why something was cancelled.

=org= by default allows you to switch states by pressing =S-LEFT= pr =S-RIGHT=.
However, when we have multiple states, we often want to switch directly to the
desired state. Add the following code to enable this option.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq org-use-fast-todo-selection t)
#+END_SRC
#+END_EXAMPLE

To switch TODO states, place your cursor onto the headline, then press =C-c
C-t=. This should bring up another buffer listing the possible states. Press the
key corresponding to your desired state, and your headline should automatically
change to reflect that.

*** =org= ellipsis

When you are hovering over a headline, you can press =TAB=. This collapses all
the text underneath the headline, and replaces the text with an ellipsis (...).
I didn't like the ellipsis, so I replaced it with a "⤵".

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⤵")
(set-face-attribute 'org-ellipsis nil :foreground "##61a49e")
#+END_SRC
#+END_EXAMPLE

*** =org= pretty bullets

The number of the bullets in your headline indicates different levels of
headlines, and they correspond to different importance levels (* matches to
=<h1>=, ** matches to =<h2>=, etc). I'd prefer to look at some prettier,
indented bullets, so I replaced them with a package called =org-bullets=.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC
#+END_EXAMPLE

*** =org= file converters

=org= can export to a bunch of different file systems. I'll go over the formats
I have set up, but in the future if you need to write a paper and transform it
into PDF or HTML format, consider writing in =org= rather than LaTex (powerful
but annoying to write) or Markdown (non-standardized and Markdown tables suck).

To convert a file, press =C-c C-e=. This should being up a side panel listing a
bunch of options to convert your files. Choose which file format to convert to,
and Emacs should output that file.

**** HTML/Markdown

=htmlize= is a package that helps you convert =org= files to an HTML page.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
   (use-package htmlize)
#+END_SRC
#+END_EXAMPLE

**** PDF/LaTex

=org= can export to PDF thorugh LaTex if you have a Tex toolchain available on
your system automatically.

**** GitHub Flavored Markdown

GitHub has it's own flavour of markdown. Well no matter, we can export to that
too. Never directly write a README.md directly again!

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm)
(eval-after-load "org"
  '(require 'ox-gfm nil t))
#+END_SRC
#+END_EXAMPLE

**** Hugo

This blog is generated with Hugo. I can write my blog posts in =org=, export
them to hugo compatible Markdown with front-matter intact, and publish them.

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :ensure t            ;Auto-install the package from Melpa (optional)
  :after ox)
#+END_SRC
#+END_EXAMPLE

*** Conclusion

My journey into Emacs and Org-Mode has been quite successful. To demonstrate,
I've written this blog post using =org=, and I hopefully plan on never writing
Markdown again. My current, ever updating configuration file can be seen at
[[https://github.com/TerrenceHo/dotfiles][My GitHub]]. Check out the ".emacs.d/configuration.org" file, GitHub can render
=org= files now!

I went from writing code manually in the .emacs file and ended up writing all my
configurations in an =org= file, that holds both the source code and
documentation for my configurations. I then also went into a brief overview
about how I configure Emacs and =org= mode specifically.

Emacs is endlessly configureable. There are insanely powerful plugins such as
MaGit (git plugin), Projectile (session/project management), Helm (completion
framework), TRAMP (SSH remote file support), autocomplete and language servers,
and more. I am still figuring out all these other tools, which goes to show how
awesome Emacs really is.

I should have a blog post up soon detailing how I organize my blog posts using
=ox-hugo=. Stay tuned for that!


** TODO Go Essentials Part 1                               :go:go_essentials:
   :PROPERTIES:
   :EXPORT_FILE_NAME: go-essentials-part-1
   :END:

*** Constructors

*** Interfaces

*** Lambda functions

*** Type Alias

*** =iota= and =enums=

*** Networking

*** Reader and Writer interfaces
** TODO Go Essentials Part 2                               :go:go_essentials:
   :PROPERTIES:
   :EXPORT_FILE_NAME: go-essentials-part-2
   :END:

*** Goroutines

*** Channels

*** Data sharing and locks
** TODO A Deep Dive into gzip's Codebase Part 1                      :C:gzip:
   :PROPERTIES:
   :EXPORT_FILE_NAME: gzip-deep-dive-part-1
   :END:
** TODO Integrating =zlib= into =gzip=                               :C:gzip:
   :PROPERTIES:
   :EXPORT_FILE_NAME: gzip-integrate-zlib
   :END:
** TODO Parallelizing gzip                          :C:gzip:parallel:threads:
   :PROPERTIES:
   :EXPORT_FILE_NAME: parallelizing-gzip
   :END:
** TODO My Journey as a Developer                                   :journey:
   :PROPERTIES:
   :EXPORT_FILE_NAME: my-journey
   :END:

This is a never-ending post of my journey as a developer.
** TODO Garbled Circuits Research                  :research:garbled_ciruits:

*** Explain Garbled Circuits

*** Explain the leaky bit problem

*** Explain our attempts to solve it
** TODO UCLA DevX internal tools             :DevX:go:backend:postgres:redis:
** TODO Computability: Recursion Theorem and the Halting Problem   :research:
** IN-PROGRESS Microsoft Internship                    :microsoft:internship:
   :PROPERTIES:
   :EXPORT_FILE_NAME: microsoft-internship
   :END:
*** How I landed my Microsoft Internship
*** Starting my internship

On July 17th, 2019, I started my Microsoft internship. We registered for I9
employment, and sat through a bunch of presentations Truthfully, they were
terribily boring to me, but it's nice to see that the Microsoft recruiters truly
believe in Microsoft's mission: /Empower every person and organization on this
planet to achieve more./

*** Camp Microsoft

Microsoft has started an intern program called Camp Microsoft, which is a
collection of intern activities and events that help interns get to know one
another and pass the time. You are put in a random group of other interns, led
by two Microsoft employees.

There are trivia nights every Tuesday. Other specific events are organized by
the group leaders.
*** My Project
*** Midpoint
*** Intern Day
*** End of the internshi
* Projects
:PROPERTIES:
:EXPORT_HUGO_SECTION: project
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

** govdev
** autofresh
** BruinBite
